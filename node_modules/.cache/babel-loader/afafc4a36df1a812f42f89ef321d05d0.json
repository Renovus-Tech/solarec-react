{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _defineProperty = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _environmentVisitor;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.environmentVisitor = exports.default = void 0;\nexports.skipAllButComputedKey = skipAllButComputedKey;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar _t = require(\"@babel/types\");\n\nvar VISITOR_KEYS = _t.VISITOR_KEYS,\n    assignmentExpression = _t.assignmentExpression,\n    booleanLiteral = _t.booleanLiteral,\n    callExpression = _t.callExpression,\n    cloneNode = _t.cloneNode,\n    identifier = _t.identifier,\n    memberExpression = _t.memberExpression,\n    sequenceExpression = _t.sequenceExpression,\n    staticBlock = _t.staticBlock,\n    stringLiteral = _t.stringLiteral,\n    thisExpression = _t.thisExpression;\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = cloneNode(objectRef);\n  var targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier(\"prototype\"));\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  var keys = VISITOR_KEYS[path.type];\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      if (key !== \"key\") path.skipKey(key);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nvar environmentVisitor = (_environmentVisitor = {}, _defineProperty(_environmentVisitor, \"\".concat(staticBlock ? \"StaticBlock|\" : \"\", \"ClassPrivateProperty|TypeAnnotation\"), function ClassPrivatePropertyTypeAnnotation(path) {\n  path.skip();\n}), _defineProperty(_environmentVisitor, \"Function\", function Function(path) {\n  if (path.isMethod()) return;\n  if (path.isArrowFunctionExpression()) return;\n  path.skip();\n}), _defineProperty(_environmentVisitor, \"Method|ClassProperty\", function MethodClassProperty(path) {\n  skipAllButComputedKey(path);\n}), _environmentVisitor);\nexports.environmentVisitor = environmentVisitor;\n\nvar visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super: function Super(path, state) {\n    var node = path.node,\n        parentPath = path.parentPath;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n}]);\n\nvar unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable: function Scopable(path, _ref) {\n    var refName = _ref.refName;\n    var binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n}]);\n\nvar specHandlers = {\n  memoise: function memoise(superMember, count) {\n    var scope = superMember.scope,\n        node = superMember.node;\n    var computed = node.computed,\n        property = node.property;\n\n    if (!computed) {\n      return;\n    }\n\n    var memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n  prop: function prop(superMember) {\n    var _superMember$node = superMember.node,\n        computed = _superMember$node.computed,\n        property = _superMember$node.property;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral(property.name);\n  },\n  get: function get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n  _get: function _get(superMember, thisRefs) {\n    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n  _getThisRefs: function _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: thisExpression()\n      };\n    }\n\n    var thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: assignmentExpression(\"=\", thisRef, thisExpression()),\n      this: cloneNode(thisRef)\n    };\n  },\n  set: function set(superMember, value) {\n    var thisRefs = this._getThisRefs();\n\n    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, booleanLiteral(superMember.isInStrictMode())]);\n  },\n  destructureSet: function destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(\"Destructuring to a super field is not supported yet.\");\n  },\n  call: function call(superMember, args) {\n    var thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);\n  },\n  optionalCall: function optionalCall(superMember, args) {\n    var thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);\n  }\n};\nvar looseHandlers = Object.assign({}, specHandlers, {\n  prop: function prop(superMember) {\n    var property = superMember.node.property;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n  get: function get(superMember) {\n    var isStatic = this.isStatic,\n        getSuperRef = this.getSuperRef;\n    var computed = superMember.node.computed;\n    var prop = this.prop(superMember);\n    var object;\n\n    if (isStatic) {\n      var _getSuperRef;\n\n      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      var _getSuperRef2;\n\n      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier(\"Object\"), identifier(\"prototype\"));\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n  set: function set(superMember, value) {\n    var computed = superMember.node.computed;\n    var prop = this.prop(superMember);\n    return assignmentExpression(\"=\", memberExpression(thisExpression(), prop, computed), value);\n  },\n  destructureSet: function destructureSet(superMember) {\n    var computed = superMember.node.computed;\n    var prop = this.prop(superMember);\n    return memberExpression(thisExpression(), prop, computed);\n  },\n  call: function call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);\n  },\n  optionalCall: function optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);\n  }\n});\n\nvar ReplaceSupers = /*#__PURE__*/function () {\n  function ReplaceSupers(opts) {\n    _classCallCheck(this, ReplaceSupers);\n\n    var _opts$constantSuper;\n\n    var path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;\n    this.opts = opts;\n  }\n\n  _createClass(ReplaceSupers, [{\n    key: \"getObjectRef\",\n    value: function getObjectRef() {\n      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n    }\n  }, {\n    key: \"getSuperRef\",\n    value: function getSuperRef() {\n      if (this.opts.superRef) return cloneNode(this.opts.superRef);\n      if (this.opts.getSuperRef) return cloneNode(this.opts.getSuperRef());\n    }\n  }, {\n    key: \"replace\",\n    value: function replace() {\n      if (this.opts.refToPreserve) {\n        this.methodPath.traverse(unshadowSuperBindingVisitor, {\n          refName: this.opts.refToPreserve.name\n        });\n      }\n\n      var handler = this.constantSuper ? looseHandlers : specHandlers;\n      (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n        file: this.file,\n        scope: this.methodPath.scope,\n        isDerivedConstructor: this.isDerivedConstructor,\n        isStatic: this.isStatic,\n        isPrivateMethod: this.isPrivateMethod,\n        getObjectRef: this.getObjectRef.bind(this),\n        getSuperRef: this.getSuperRef.bind(this),\n        boundGet: handler.get\n      }, handler));\n    }\n  }]);\n\n  return ReplaceSupers;\n}();\n\nexports.default = ReplaceSupers;","map":{"version":3,"sources":["C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/@babel/core/node_modules/@babel/helper-replace-supers/lib/index.js"],"names":["Object","defineProperty","exports","value","environmentVisitor","default","skipAllButComputedKey","_traverse","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_t","VISITOR_KEYS","assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","staticBlock","stringLiteral","thisExpression","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","path","node","computed","skip","keys","type","key","skipKey","isMethod","isArrowFunctionExpression","visitor","visitors","merge","Super","state","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","this","isDerivedConstructor","thisRef","generateDeclaredUidIdentifier","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optionalCall","looseHandlers","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","constantSuper","isLoose","refToPreserve","traverse","handler","bind","boundGet"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.environmentVisitor = exports.default = void 0;\nexports.skipAllButComputedKey = skipAllButComputedKey;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  staticBlock,\n  stringLiteral,\n  thisExpression\n} = _t;\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = cloneNode(objectRef);\n  const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier(\"prototype\"));\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}\n\nconst environmentVisitor = {\n  [`${staticBlock ? \"StaticBlock|\" : \"\"}ClassPrivateProperty|TypeAnnotation`](path) {\n    path.skip();\n  },\n\n  Function(path) {\n    if (path.isMethod()) return;\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n  },\n\n  \"Method|ClassProperty\"(path) {\n    skipAllButComputedKey(path);\n  }\n\n};\nexports.environmentVisitor = environmentVisitor;\n\nconst visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n\n}]);\n\nconst unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n\n}]);\n\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral(property.name);\n  },\n\n  get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(superMember, thisRefs) {\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n\n  _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: thisExpression()\n      };\n    }\n\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: assignmentExpression(\"=\", thisRef, thisExpression()),\n      this: cloneNode(thisRef)\n    };\n  },\n\n  set(superMember, value) {\n    const thisRefs = this._getThisRefs();\n\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, booleanLiteral(superMember.isInStrictMode())]);\n  },\n\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n\n  call(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);\n  }\n\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(superMember) {\n    const {\n      isStatic,\n      getSuperRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n\n    if (isStatic) {\n      var _getSuperRef;\n\n      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      var _getSuperRef2;\n\n      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier(\"Object\"), identifier(\"prototype\"));\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return assignmentExpression(\"=\", memberExpression(thisExpression(), prop, computed), value);\n  },\n\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);\n  }\n\n});\n\nclass ReplaceSupers {\n  constructor(opts) {\n    var _opts$constantSuper;\n\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;\n    this.opts = opts;\n  }\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) return cloneNode(this.opts.getSuperRef());\n  }\n\n  replace() {\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n    (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      boundGet: handler.get\n    }, handler));\n  }\n\n}\n\nexports.default = ReplaceSupers;"]},"metadata":{},"sourceType":"script"}