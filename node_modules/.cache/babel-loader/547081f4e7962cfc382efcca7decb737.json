{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _slicedToArray = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _templateObject;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\n\nvar assignmentExpression = _t.assignmentExpression,\n    callExpression = _t.callExpression,\n    cloneNode = _t.cloneNode,\n    expressionStatement = _t.expressionStatement,\n    getOuterBindingIdentifiers = _t.getOuterBindingIdentifiers,\n    identifier = _t.identifier,\n    isMemberExpression = _t.isMemberExpression,\n    isVariableDeclaration = _t.isVariableDeclaration,\n    jsxIdentifier = _t.jsxIdentifier,\n    jsxMemberExpression = _t.jsxMemberExpression,\n    memberExpression = _t.memberExpression,\n    numericLiteral = _t.numericLiteral,\n    sequenceExpression = _t.sequenceExpression,\n    stringLiteral = _t.stringLiteral,\n    variableDeclaration = _t.variableDeclaration,\n    variableDeclarator = _t.variableDeclarator;\n\nfunction isInType(path) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n\n      case \"ExportSpecifier\":\n        return path.parentPath.parent.exportKind === \"type\";\n\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n\n    }\n  } while (path = path.parentPath);\n}\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  var imported = new Map();\n  var exported = new Map();\n\n  var requeueInParent = function requeueInParent(path) {\n    programPath.requeue(path);\n  };\n\n  var _iterator = _createForOfIteratorHelper(metadata.source),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          source = _step$value[0],\n          data = _step$value[1];\n\n      var _iterator3 = _createForOfIteratorHelper(data.imports),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              localName = _step3$value[0],\n              importName = _step3$value[1];\n\n          imported.set(localName, [source, importName, null]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(data.importsNamespace),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _localName = _step4.value;\n          imported.set(_localName, [source, null, _localName]);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(metadata.local),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _exportMeta;\n\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          local = _step2$value[0],\n          _data = _step2$value[1];\n\n      var exportMeta = exported.get(local);\n\n      if (!exportMeta) {\n        exportMeta = [];\n        exported.set(local, exportMeta);\n      }\n\n      (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var rewriteBindingInitVisitorState = {\n    metadata: metadata,\n    requeueInParent: requeueInParent,\n    scope: programPath.scope,\n    exported: exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([].concat(_toConsumableArray(Array.from(imported.keys())), _toConsumableArray(Array.from(exported.keys())))));\n  var rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata: metadata,\n    requeueInParent: requeueInParent,\n    scope: programPath.scope,\n    imported: imported,\n    exported: exported,\n    buildImportReference: function buildImportReference(_ref, identNode) {\n      var _ref2 = _slicedToArray(_ref, 3),\n          source = _ref2[0],\n          importName = _ref2[1],\n          localName = _ref2[2];\n\n      var meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = callExpression(identNode, []);\n        return identNode;\n      }\n\n      var namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      var computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nvar rewriteBindingInitVisitor = {\n  Scope: function Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration: function ClassDeclaration(path) {\n    var requeueInParent = this.requeueInParent,\n        exported = this.exported,\n        metadata = this.metadata;\n    var id = path.node.id;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    var localName = id.name;\n    var exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration: function VariableDeclaration(path) {\n    var requeueInParent = this.requeueInParent,\n        exported = this.exported,\n        metadata = this.metadata;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {\n      var exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n};\n\nvar buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {\n  return (exportNames || []).reduce(function (expr, exportName) {\n    var stringSpecifiers = metadata.stringSpecifiers;\n    var computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nvar buildImportThrow = function buildImportThrow(localName) {\n  return _template.default.expression.ast(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    (function() {\\n      throw new Error('\\\"' + '\", \"' + '\\\" is read-only.');\\n    })()\\n  \"])), localName);\n};\n\nvar rewriteReferencesVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path) {\n    var seen = this.seen,\n        buildImportReference = this.buildImportReference,\n        scope = this.scope,\n        imported = this.imported,\n        requeueInParent = this.requeueInParent;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    var localName = path.node.name;\n    var importData = imported.get(localName);\n\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(\"Cannot transform the imported binding \\\"\".concat(localName, \"\\\" since it's also used in a type annotation. \") + \"Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.\");\n      }\n\n      var localBinding = path.scope.getBinding(localName);\n      var rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      var ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        var object = ref.object,\n            property = ref.property;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n  AssignmentExpression: {\n    exit: function exit(path) {\n      var _this = this;\n\n      var scope = this.scope,\n          seen = this.seen,\n          imported = this.imported,\n          exported = this.exported,\n          requeueInParent = this.requeueInParent,\n          buildImportReference = this.buildImportReference;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      var left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        var localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        var exportedNames = exported.get(localName);\n        var importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          var assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        var ids = left.getOuterBindingIdentifiers();\n        var programScopeIds = Object.keys(ids).filter(function (localName) {\n          return scope.getBinding(localName) === path.scope.getBinding(localName);\n        });\n        var id = programScopeIds.find(function (localName) {\n          return imported.has(localName);\n        });\n\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        var items = [];\n        programScopeIds.forEach(function (localName) {\n          var exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          var node = sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          var statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n  },\n  \"ForOfStatement|ForInStatement\": function ForOfStatementForInStatement(path) {\n    var scope = path.scope,\n        node = path.node;\n    var left = node.left;\n    var exported = this.exported,\n        imported = this.imported,\n        programScope = this.scope;\n\n    if (!isVariableDeclaration(left)) {\n      var didTransformExport = false,\n          importConstViolationName;\n      var loopBodyScope = path.get(\"body\").scope;\n\n      for (var _i = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers(left)); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      var bodyPath = path.get(\"body\");\n      var newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/@babel/core/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"],"names":["Object","defineProperty","exports","value","default","rewriteLiveReferences","_assert","require","_t","_template","_helperSimpleAccess","assignmentExpression","callExpression","cloneNode","expressionStatement","getOuterBindingIdentifiers","identifier","isMemberExpression","isVariableDeclaration","jsxIdentifier","jsxMemberExpression","memberExpression","numericLiteral","sequenceExpression","stringLiteral","variableDeclaration","variableDeclarator","isInType","path","parent","type","parentPath","exportKind","isStatement","isExpression","programPath","metadata","imported","Map","exported","requeueInParent","requeue","source","data","imports","localName","importName","set","importsNamespace","local","exportMeta","get","push","names","rewriteBindingInitVisitorState","scope","traverse","rewriteBindingInitVisitor","Set","Array","from","keys","rewriteReferencesVisitorState","seen","WeakSet","buildImportReference","identNode","meta","lazy","namespace","name","interop","computed","stringSpecifiers","has","rewriteReferencesVisitor","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","forEach","localExpr","reduce","expr","exportName","buildImportThrow","expression","ast","ReferencedIdentifier","add","importData","buildCodeFrameError","localBinding","getBinding","rootBinding","ref","loc","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","replaceWith","isJSXIdentifier","object","property","AssignmentExpression","exit","left","isIdentifier","exportedNames","operator","assignment","right","ids","programScopeIds","filter","find","items","isExpressionStatement","programScope","didTransformExport","importConstViolationName","loopBodyScope","hasOwnBinding","rename","ensureBlock","bodyPath","newLoopId","generateUidIdentifierBasedOnNode","registerDeclaration","unshiftContainer"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\n\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction isInType(path) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n\n      case \"ExportSpecifier\":\n        return path.parentPath.parent.exportKind === \"type\";\n\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n\n    }\n  } while (path = path.parentPath);\n}\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(`Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);\n      }\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      imported,\n      scope: programScope\n    } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n          importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n\n};"]},"metadata":{},"sourceType":"script"}