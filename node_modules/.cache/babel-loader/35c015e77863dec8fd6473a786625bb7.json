{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _t = require(\"@babel/types\");\n\nvar VISITOR_KEYS = _t.VISITOR_KEYS,\n    assignmentExpression = _t.assignmentExpression,\n    identifier = _t.identifier,\n    toExpression = _t.toExpression,\n    variableDeclaration = _t.variableDeclaration,\n    variableDeclarator = _t.variableDeclarator;\nvar renameVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {\n    var node = _ref.node;\n\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n  \"AssignmentExpression|Declaration|VariableDeclarator\": function AssignmentExpressionDeclarationVariableDeclarator(path, state) {\n    if (path.isVariableDeclaration()) return;\n    var ids = path.getOuterBindingIdentifiers();\n\n    for (var name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\n\nvar Renamer = /*#__PURE__*/function () {\n  function Renamer(binding, oldName, newName) {\n    _classCallCheck(this, Renamer);\n\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  _createClass(Renamer, [{\n    key: \"maybeConvertFromExportDeclaration\",\n    value: function maybeConvertFromExportDeclaration(parentDeclar) {\n      var maybeExportDeclar = parentDeclar.parentPath;\n\n      if (!maybeExportDeclar.isExportDeclaration()) {\n        return;\n      }\n\n      if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n        return;\n      }\n\n      (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n    }\n  }, {\n    key: \"maybeConvertFromClassFunctionDeclaration\",\n    value: function maybeConvertFromClassFunctionDeclaration(path) {\n      return;\n      if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n      if (this.binding.kind !== \"hoisted\") return;\n      path.node.id = identifier(this.oldName);\n      path.node._blockHoist = 3;\n      path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\n    }\n  }, {\n    key: \"maybeConvertFromClassFunctionExpression\",\n    value: function maybeConvertFromClassFunctionExpression(path) {\n      return;\n      if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n      if (this.binding.kind !== \"local\") return;\n      path.node.id = identifier(this.oldName);\n      this.binding.scope.parent.push({\n        id: identifier(this.newName)\n      });\n      path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(block) {\n      var _this = this;\n\n      var binding = this.binding,\n          oldName = this.oldName,\n          newName = this.newName;\n      var scope = binding.scope,\n          path = binding.path;\n      var parentDeclar = path.find(function (path) {\n        return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();\n      });\n\n      if (parentDeclar) {\n        var bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n        if (bindingIds[oldName] === binding.identifier) {\n          this.maybeConvertFromExportDeclaration(parentDeclar);\n        }\n      }\n\n      var blockToTraverse = block || scope.block;\n\n      if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n        blockToTraverse.cases.forEach(function (c) {\n          scope.traverse(c, renameVisitor, _this);\n        });\n      } else {\n        scope.traverse(blockToTraverse, renameVisitor, this);\n      }\n\n      if (!block) {\n        scope.removeOwnBinding(oldName);\n        scope.bindings[newName] = binding;\n        this.binding.identifier.name = newName;\n      }\n\n      if (parentDeclar) {\n        this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n        this.maybeConvertFromClassFunctionExpression(parentDeclar);\n      }\n    }\n  }]);\n\n  return Renamer;\n}();\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  var keys = VISITOR_KEYS[path.type];\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      if (key !== \"key\") path.skipKey(key);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}","map":{"version":3,"sources":["C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/lib/renamer.js"],"names":["Object","defineProperty","exports","value","default","_binding","require","_helperSplitExportDeclaration","_t","VISITOR_KEYS","assignmentExpression","identifier","toExpression","variableDeclaration","variableDeclarator","renameVisitor","ReferencedIdentifier","state","node","name","oldName","newName","Scope","path","scope","bindingIdentifierEquals","binding","skipAllButComputedMethodKey","isVariableDeclaration","ids","getOuterBindingIdentifiers","Renamer","parentDeclar","maybeExportDeclar","parentPath","isExportDeclaration","isExportDefaultDeclaration","get","id","isFunctionDeclaration","isClassDeclaration","kind","_blockHoist","replaceWith","isFunctionExpression","isClassExpression","parent","push","block","find","isDeclaration","bindingIds","maybeConvertFromExportDeclaration","blockToTraverse","type","cases","forEach","c","traverse","removeOwnBinding","bindings","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","isMethod","computed","skip","keys","key","skipKey"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  identifier,\n  toExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: identifier(this.newName)\n    });\n    path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}"]},"metadata":{},"sourceType":"script"}