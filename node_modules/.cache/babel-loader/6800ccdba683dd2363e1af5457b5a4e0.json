{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _t = require('@babel/types');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function get() {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar _t__namespace = /*#__PURE__*/_interopNamespace(_t);\n\nfunction willPathCastToBoolean(path) {\n  var maybeWrapped = path;\n  var node = maybeWrapped.node,\n      parentPath = maybeWrapped.parentPath;\n\n  if (parentPath.isLogicalExpression()) {\n    var _parentPath$node = parentPath.node,\n        operator = _parentPath$node.operator,\n        right = _parentPath$node.right;\n\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n\n  if (parentPath.isSequenceExpression()) {\n    var expressions = parentPath.node.expressions;\n\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\n\nvar LOGICAL_OPERATORS = _t__namespace.LOGICAL_OPERATORS,\n    arrowFunctionExpression = _t__namespace.arrowFunctionExpression,\n    assignmentExpression = _t__namespace.assignmentExpression,\n    binaryExpression = _t__namespace.binaryExpression,\n    booleanLiteral = _t__namespace.booleanLiteral,\n    callExpression = _t__namespace.callExpression,\n    cloneNode = _t__namespace.cloneNode,\n    conditionalExpression = _t__namespace.conditionalExpression,\n    identifier = _t__namespace.identifier,\n    isMemberExpression = _t__namespace.isMemberExpression,\n    isOptionalCallExpression = _t__namespace.isOptionalCallExpression,\n    isOptionalMemberExpression = _t__namespace.isOptionalMemberExpression,\n    isUpdateExpression = _t__namespace.isUpdateExpression,\n    logicalExpression = _t__namespace.logicalExpression,\n    memberExpression = _t__namespace.memberExpression,\n    nullLiteral = _t__namespace.nullLiteral,\n    numericLiteral = _t__namespace.numericLiteral,\n    optionalCallExpression = _t__namespace.optionalCallExpression,\n    optionalMemberExpression = _t__namespace.optionalMemberExpression,\n    sequenceExpression = _t__namespace.sequenceExpression,\n    unaryExpression = _t__namespace.unaryExpression;\n\nvar AssignmentMemoiser = /*#__PURE__*/function () {\n  function AssignmentMemoiser() {\n    _classCallCheck(this, AssignmentMemoiser);\n\n    this._map = void 0;\n    this._map = new WeakMap();\n  }\n\n  _createClass(AssignmentMemoiser, [{\n    key: \"has\",\n    value: function has(key) {\n      return this._map.has(key);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      if (!this.has(key)) return;\n\n      var record = this._map.get(key);\n\n      var value = record.value;\n      record.count--;\n\n      if (record.count === 0) {\n        return assignmentExpression(\"=\", value, key);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value, count) {\n      return this._map.set(key, {\n        count: count,\n        value: value\n      });\n    }\n  }]);\n\n  return AssignmentMemoiser;\n}();\n\nfunction toNonOptional(path, base) {\n  var node = path.node;\n\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    var callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      var object = callee.node.object;\n      var context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(assignmentExpression(\"=\", context, object));\n      return callExpression(memberExpression(base, identifier(\"call\")), [context].concat(_toConsumableArray(path.node.arguments)));\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    var _path = path,\n        parentPath = _path.parentPath,\n        container = _path.container,\n        listKey = _path.listKey;\n    var parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nvar handle = {\n  memoise: function memoise() {},\n  handle: function handle(member, noDocumentAll) {\n    var node = member.node,\n        parent = member.parent,\n        parentPath = member.parentPath,\n        scope = member.scope;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      var endPath = member.find(function (_ref) {\n        var node = _ref.node,\n            parent = _ref.parent;\n\n        if (isOptionalMemberExpression(parent)) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (isOptionalCallExpression(parent)) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));\n        return;\n      }\n\n      var willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n      var rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(\"can't handle assignment\");\n      }\n\n      var isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      });\n\n      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get(\"property\").isPrivateName()) {\n        throw member.buildCodeFrameError(\"can't delete a private class element\");\n      }\n\n      var startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(\"Internal error: unexpected \".concat(startingOptional.node.type));\n      }\n\n      var startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      var startingNode = startingOptional.node[startingProp];\n      var baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      var baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      var parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n\n      var isOptionalCall = function isOptionalCall(parent) {\n        return parentIsOptionalCall;\n      };\n\n      var parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (isOptionalCall()) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      var regular = member.node;\n\n      for (var current = member; current !== endPath;) {\n        var _parentPath = current.parentPath;\n\n        if (_parentPath === endPath && isOptionalCall() && parent.optional) {\n          regular = _parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(_parentPath, regular);\n        current = _parentPath;\n      }\n\n      var context;\n      var endParentPath = endPath.parentPath;\n\n      if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        var _regular = regular,\n            object = _regular.object;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      var replacementPath = endPath;\n\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      var baseMemoised = baseNeedsMemoised ? assignmentExpression(\"=\", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        var nonNullishCheck;\n\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\"&&\", binaryExpression(\"!==\", baseMemoised, nullLiteral()), binaryExpression(\"!==\", cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(logicalExpression(\"&&\", nonNullishCheck, regular));\n      } else {\n        var nullishCheck;\n\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\"||\", binaryExpression(\"===\", baseMemoised, nullLiteral()), binaryExpression(\"===\", cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));\n      }\n\n      if (context) {\n        var endParent = endParentPath.node;\n        endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier(\"call\"), false, true), [cloneNode(context)].concat(_toConsumableArray(endParent.arguments)), false));\n      }\n\n      return;\n    }\n\n    if (isUpdateExpression(parent, {\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      var operator = parent.operator,\n          prefix = parent.prefix;\n      this.memoise(member, 2);\n      var value = binaryExpression(operator[0], unaryExpression(\"+\", this.get(member)), numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        var _scope = member.scope;\n\n        var ref = _scope.generateUidIdentifierBasedOnNode(node);\n\n        _scope.push({\n          id: ref\n        });\n\n        value.left = assignmentExpression(\"=\", cloneNode(ref), value.left);\n        parentPath.replaceWith(sequenceExpression([this.set(member, value), cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      var _parentPath$node2 = parentPath.node,\n          _operator = _parentPath$node2.operator,\n          _value = _parentPath$node2.right;\n\n      if (_operator === \"=\") {\n        parentPath.replaceWith(this.set(member, _value));\n      } else {\n        var operatorTrunc = _operator.slice(0, -1);\n\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          this.memoise(member, 1);\n          parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, _value)));\n        } else {\n          this.memoise(member, 2);\n          parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), _value)));\n        }\n      }\n\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));\n        return;\n      }\n\n      parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      member.replaceWith(this.boundGet(member));\n    } else {\n      member.replaceWith(this.get(member));\n    }\n  }\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}\n\nexports.default = memberExpressionToFunctions;","map":{"version":3,"sources":["../src/util.ts","../src/index.ts"],"names":["maybeWrapped","parentPath","right","operator","node","willPathCastToBoolean","expressions","test","LOGICAL_OPERATORS","arrowFunctionExpression","assignmentExpression","binaryExpression","booleanLiteral","callExpression","cloneNode","conditionalExpression","identifier","isMemberExpression","isOptionalCallExpression","isOptionalMemberExpression","isUpdateExpression","logicalExpression","memberExpression","nullLiteral","numericLiteral","optionalCallExpression","optionalMemberExpression","sequenceExpression","unaryExpression","_map","constructor","has","get","record","value","set","count","path","callee","object","context","listKey","parentNode","container","handle","memoise","scope","member","isInDetachedTree","endPath","parent","willEndPathCastToBoolean","rootParentPath","argument","left","isDeleteOperation","startingOptional","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","toNonOptional","regular","current","endParentPath","optional","replacementPath","baseMemoised","nonNullishCheck","nullishCheck","endParent","prefix","ref","id","operatorTrunc","memoiser"],"mappings":"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","sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  numericLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.LVal }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.LVal, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const { object } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee\n        .get(\"object\")\n        .replaceWith(assignmentExpression(\"=\", context as t.LVal, object));\n\n      return callExpression(memberExpression(base, identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression()\n        ? \"object\"\n        : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? assignmentExpression(\"=\", cloneNode(baseRef), cloneNode(startingNode))\n        : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\n            \"&&\",\n            binaryExpression(\"!==\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"!==\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\n            \"||\",\n            binaryExpression(\"===\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"===\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          optionalCallExpression(\n            optionalMemberExpression(\n              endParent.callee,\n              identifier(\"call\"),\n              false,\n              true,\n            ),\n            [cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (_ref = (+_get(MEMBER))) + 1), _ref\n    // ++MEMBER   ->   _set(MEMBER, (+_get(MEMBER)) + 1)\n    if (isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const value = binaryExpression(\n        operator[0] as \"+\" | \"-\",\n        unaryExpression(\"+\", this.get(member)),\n        numericLiteral(1),\n      );\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const { scope } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref });\n\n        value.left = assignmentExpression(\n          \"=\",\n          cloneNode(ref),\n          // @ts-expect-error todo(flow->ts) value.left is possibly PrivateName, which is not usable here\n          value.left,\n        );\n\n        parentPath.replaceWith(\n          sequenceExpression([this.set(member, value), cloneNode(ref)]),\n        );\n      }\n      return;\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            logicalExpression(\n              operatorTrunc as t.LogicalExpression[\"operator\"],\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              binaryExpression(\n                operatorTrunc as t.BinaryExpression[\"operator\"],\n                this.get(member),\n                value,\n              ),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n}\n\nexport interface HandlerState<State = {}> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState = {}>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"]},"metadata":{},"sourceType":"script"}