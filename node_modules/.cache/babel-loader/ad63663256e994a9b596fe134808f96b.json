{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nvar BOOLEAN_NUMBER_BINARY_OPERATORS = _t.BOOLEAN_NUMBER_BINARY_OPERATORS,\n    createFlowUnionType = _t.createFlowUnionType,\n    createTSUnionType = _t.createTSUnionType,\n    createTypeAnnotationBasedOnTypeof = _t.createTypeAnnotationBasedOnTypeof,\n    createUnionTypeAnnotation = _t.createUnionTypeAnnotation,\n    isTSTypeAnnotation = _t.isTSTypeAnnotation,\n    numberTypeAnnotation = _t.numberTypeAnnotation,\n    voidTypeAnnotation = _t.voidTypeAnnotation;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  var binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  var types = [];\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  var testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    var _constantViolations;\n\n    (_constantViolations = constantViolations).push.apply(_constantViolations, functionConstantViolations);\n\n    var _iterator = _createForOfIteratorHelper(constantViolations),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var violation = _step.value;\n        types.push(violation.getTypeAnnotation());\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n    return createTSUnionType(types);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(types);\n  }\n\n  return createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n\n    var status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n  var target;\n\n  if (left.isIdentifier({\n    name: name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name: name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  var typeofPath;\n  var typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name: name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  var parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  var ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  for (var i = 0; i < paths.length; i++) {\n    var _path = paths[i];\n\n    if (_path.isLogicalExpression()) {\n      if (_path.node.operator === \"&&\") {\n        paths.push(_path.get(\"left\"));\n        paths.push(_path.get(\"right\"));\n      }\n    } else if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n      return {\n        typeAnnotation: createTSUnionType(types),\n        ifStatement: ifStatement\n      };\n    }\n\n    if (createFlowUnionType) {\n      return {\n        typeAnnotation: createFlowUnionType(types),\n        ifStatement: ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","map":{"version":3,"sources":["C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"],"names":["Object","defineProperty","exports","value","default","_default","_t","require","BOOLEAN_NUMBER_BINARY_OPERATORS","createFlowUnionType","createTSUnionType","createTypeAnnotationBasedOnTypeof","createUnionTypeAnnotation","isTSTypeAnnotation","numberTypeAnnotation","voidTypeAnnotation","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","path","types","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","violation","getTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","key","isFunction","test","paths","i","isLogicalExpression","isBinaryExpression","type"],"mappings":"AAAA;;;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,QAAlB;;AAEA,IAAIC,EAAE,GAAGC,OAAO,CAAC,cAAD,CAAhB;;AAEA,IACEC,+BADF,GASIF,EATJ,CACEE,+BADF;AAAA,IAEEC,mBAFF,GASIH,EATJ,CAEEG,mBAFF;AAAA,IAGEC,iBAHF,GASIJ,EATJ,CAGEI,iBAHF;AAAA,IAIEC,iCAJF,GASIL,EATJ,CAIEK,iCAJF;AAAA,IAKEC,yBALF,GASIN,EATJ,CAKEM,yBALF;AAAA,IAMEC,kBANF,GASIP,EATJ,CAMEO,kBANF;AAAA,IAOEC,oBAPF,GASIR,EATJ,CAOEQ,oBAPF;AAAA,IAQEC,kBARF,GASIT,EATJ,CAQES,kBARF;;AAWA,SAASV,QAAT,CAAkBW,IAAlB,EAAwB;AACtB,MAAI,CAAC,KAAKC,YAAL,EAAL,EAA0B;AAC1B,MAAMC,OAAO,GAAG,KAAKC,KAAL,CAAWC,UAAX,CAAsBJ,IAAI,CAACK,IAA3B,CAAhB;;AAEA,MAAIH,OAAJ,EAAa;AACX,QAAIA,OAAO,CAACI,UAAR,CAAmBC,cAAvB,EAAuC;AACrC,aAAOL,OAAO,CAACI,UAAR,CAAmBC,cAA1B;AACD,KAFD,MAEO;AACL,aAAOC,0CAA0C,CAACN,OAAD,EAAU,IAAV,EAAgBF,IAAI,CAACK,IAArB,CAAjD;AACD;AACF;;AAED,MAAIL,IAAI,CAACK,IAAL,KAAc,WAAlB,EAA+B;AAC7B,WAAON,kBAAkB,EAAzB;AACD,GAFD,MAEO,IAAIC,IAAI,CAACK,IAAL,KAAc,KAAd,IAAuBL,IAAI,CAACK,IAAL,KAAc,UAAzC,EAAqD;AAC1D,WAAOP,oBAAoB,EAA3B;AACD,GAFM,MAEA,IAAIE,IAAI,CAACK,IAAL,KAAc,WAAlB,EAA+B,CAAE;AACzC;;AAED,SAASG,0CAAT,CAAoDN,OAApD,EAA6DO,IAA7D,EAAmEJ,IAAnE,EAAyE;AACvE,MAAMK,KAAK,GAAG,EAAd;AACA,MAAMC,0BAA0B,GAAG,EAAnC;AACA,MAAIC,kBAAkB,GAAGC,2BAA2B,CAACX,OAAD,EAAUO,IAAV,EAAgBE,0BAAhB,CAApD;AACA,MAAMG,QAAQ,GAAGC,wBAAwB,CAACb,OAAD,EAAUO,IAAV,EAAgBJ,IAAhB,CAAzC;;AAEA,MAAIS,QAAJ,EAAc;AACZ,QAAME,sBAAsB,GAAGH,2BAA2B,CAACX,OAAD,EAAUY,QAAQ,CAACG,WAAnB,CAA1D;AACAL,IAAAA,kBAAkB,GAAGA,kBAAkB,CAACM,MAAnB,CAA0B,UAAAT,IAAI;AAAA,aAAIO,sBAAsB,CAACG,OAAvB,CAA+BV,IAA/B,IAAuC,CAA3C;AAAA,KAA9B,CAArB;AACAC,IAAAA,KAAK,CAACU,IAAN,CAAWN,QAAQ,CAACP,cAApB;AACD;;AAED,MAAIK,kBAAkB,CAACS,MAAvB,EAA+B;AAAA;;AAC7B,2BAAAT,kBAAkB,EAACQ,IAAnB,4BAA2BT,0BAA3B;;AAD6B,+CAGLC,kBAHK;AAAA;;AAAA;AAG7B,0DAA4C;AAAA,YAAjCU,SAAiC;AAC1CZ,QAAAA,KAAK,CAACU,IAAN,CAAWE,SAAS,CAACC,iBAAV,EAAX;AACD;AAL4B;AAAA;AAAA;AAAA;AAAA;AAM9B;;AAED,MAAI,CAACb,KAAK,CAACW,MAAX,EAAmB;AACjB;AACD;;AAED,MAAIxB,kBAAkB,CAACa,KAAK,CAAC,CAAD,CAAN,CAAlB,IAAgChB,iBAApC,EAAuD;AACrD,WAAOA,iBAAiB,CAACgB,KAAD,CAAxB;AACD;;AAED,MAAIjB,mBAAJ,EAAyB;AACvB,WAAOA,mBAAmB,CAACiB,KAAD,CAA1B;AACD;;AAED,SAAOd,yBAAyB,CAACc,KAAD,CAAhC;AACD;;AAED,SAASG,2BAAT,CAAqCX,OAArC,EAA8CO,IAA9C,EAAoDe,SAApD,EAA+D;AAC7D,MAAMC,UAAU,GAAGvB,OAAO,CAACU,kBAAR,CAA2Bc,KAA3B,EAAnB;AACAD,EAAAA,UAAU,CAACE,OAAX,CAAmBzB,OAAO,CAACO,IAA3B;AACA,SAAOgB,UAAU,CAACP,MAAX,CAAkB,UAAAI,SAAS,EAAI;AACpCA,IAAAA,SAAS,GAAGA,SAAS,CAACM,OAAV,EAAZ;;AAEA,QAAMC,MAAM,GAAGP,SAAS,CAACQ,+BAAV,CAA0CrB,IAA1C,CAAf;;AAEA,QAAIe,SAAS,IAAIK,MAAM,KAAK,SAA5B,EAAuCL,SAAS,CAACJ,IAAV,CAAeE,SAAf;AACvC,WAAOO,MAAM,KAAK,QAAlB;AACD,GAPM,CAAP;AAQD;;AAED,SAASE,mCAAT,CAA6C1B,IAA7C,EAAmDI,IAAnD,EAAyD;AACvD,MAAMuB,QAAQ,GAAGvB,IAAI,CAACT,IAAL,CAAUgC,QAA3B;AACA,MAAMC,KAAK,GAAGxB,IAAI,CAACyB,GAAL,CAAS,OAAT,EAAkBN,OAAlB,EAAd;AACA,MAAMO,IAAI,GAAG1B,IAAI,CAACyB,GAAL,CAAS,MAAT,EAAiBN,OAAjB,EAAb;AACA,MAAIQ,MAAJ;;AAEA,MAAID,IAAI,CAACE,YAAL,CAAkB;AACpBhC,IAAAA,IAAI,EAAJA;AADoB,GAAlB,CAAJ,EAEI;AACF+B,IAAAA,MAAM,GAAGH,KAAT;AACD,GAJD,MAIO,IAAIA,KAAK,CAACI,YAAN,CAAmB;AAC5BhC,IAAAA,IAAI,EAAJA;AAD4B,GAAnB,CAAJ,EAEH;AACF+B,IAAAA,MAAM,GAAGD,IAAT;AACD;;AAED,MAAIC,MAAJ,EAAY;AACV,QAAIJ,QAAQ,KAAK,KAAjB,EAAwB;AACtB,aAAOI,MAAM,CAACb,iBAAP,EAAP;AACD;;AAED,QAAI/B,+BAA+B,CAAC2B,OAAhC,CAAwCa,QAAxC,KAAqD,CAAzD,EAA4D;AAC1D,aAAOlC,oBAAoB,EAA3B;AACD;;AAED;AACD;;AAED,MAAIkC,QAAQ,KAAK,KAAb,IAAsBA,QAAQ,KAAK,IAAvC,EAA6C;AAC7C,MAAIM,UAAJ;AACA,MAAIC,QAAJ;;AAEA,MAAIJ,IAAI,CAACK,iBAAL,CAAuB;AACzBR,IAAAA,QAAQ,EAAE;AADe,GAAvB,CAAJ,EAEI;AACFM,IAAAA,UAAU,GAAGH,IAAb;AACAI,IAAAA,QAAQ,GAAGN,KAAX;AACD,GALD,MAKO,IAAIA,KAAK,CAACO,iBAAN,CAAwB;AACjCR,IAAAA,QAAQ,EAAE;AADuB,GAAxB,CAAJ,EAEH;AACFM,IAAAA,UAAU,GAAGL,KAAb;AACAM,IAAAA,QAAQ,GAAGJ,IAAX;AACD;;AAED,MAAI,CAACG,UAAL,EAAiB;AACjB,MAAI,CAACA,UAAU,CAACJ,GAAX,CAAe,UAAf,EAA2BG,YAA3B,CAAwC;AAC3ChC,IAAAA,IAAI,EAAJA;AAD2C,GAAxC,CAAL,EAEI;AACJkC,EAAAA,QAAQ,GAAGA,QAAQ,CAACX,OAAT,EAAX;AACA,MAAI,CAACW,QAAQ,CAACE,SAAT,EAAL,EAA2B;AAC3B,MAAMC,SAAS,GAAGH,QAAQ,CAACvC,IAAT,CAAcb,KAAhC;AACA,MAAI,OAAOuD,SAAP,KAAqB,QAAzB,EAAmC;AACnC,SAAO/C,iCAAiC,CAAC+C,SAAD,CAAxC;AACD;;AAED,SAASC,wBAAT,CAAkCzC,OAAlC,EAA2CO,IAA3C,EAAiDJ,IAAjD,EAAuD;AACrD,MAAIuC,UAAJ;;AAEA,SAAOA,UAAU,GAAGnC,IAAI,CAACmC,UAAzB,EAAqC;AACnC,QAAIA,UAAU,CAACC,aAAX,MAA8BD,UAAU,CAACE,uBAAX,EAAlC,EAAwE;AACtE,UAAIrC,IAAI,CAACsC,GAAL,KAAa,MAAjB,EAAyB;AACvB;AACD;;AAED,aAAOH,UAAP;AACD;;AAED,QAAIA,UAAU,CAACI,UAAX,EAAJ,EAA6B;AAC3B,UAAIJ,UAAU,CAACA,UAAX,CAAsBzC,KAAtB,CAA4BC,UAA5B,CAAuCC,IAAvC,MAAiDH,OAArD,EAA8D;AAC/D;;AAEDO,IAAAA,IAAI,GAAGmC,UAAP;AACD;AACF;;AAED,SAAS7B,wBAAT,CAAkCb,OAAlC,EAA2CO,IAA3C,EAAiDJ,IAAjD,EAAuD;AACrD,MAAMY,WAAW,GAAG0B,wBAAwB,CAACzC,OAAD,EAAUO,IAAV,EAAgBJ,IAAhB,CAA5C;AACA,MAAI,CAACY,WAAL,EAAkB;AAClB,MAAMgC,IAAI,GAAGhC,WAAW,CAACiB,GAAZ,CAAgB,MAAhB,CAAb;AACA,MAAMgB,KAAK,GAAG,CAACD,IAAD,CAAd;AACA,MAAMvC,KAAK,GAAG,EAAd;;AAEA,OAAK,IAAIyC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAAC7B,MAA1B,EAAkC8B,CAAC,EAAnC,EAAuC;AACrC,QAAM1C,KAAI,GAAGyC,KAAK,CAACC,CAAD,CAAlB;;AAEA,QAAI1C,KAAI,CAAC2C,mBAAL,EAAJ,EAAgC;AAC9B,UAAI3C,KAAI,CAACT,IAAL,CAAUgC,QAAV,KAAuB,IAA3B,EAAiC;AAC/BkB,QAAAA,KAAK,CAAC9B,IAAN,CAAWX,KAAI,CAACyB,GAAL,CAAS,MAAT,CAAX;AACAgB,QAAAA,KAAK,CAAC9B,IAAN,CAAWX,KAAI,CAACyB,GAAL,CAAS,OAAT,CAAX;AACD;AACF,KALD,MAKO,IAAIzB,KAAI,CAAC4C,kBAAL,EAAJ,EAA+B;AACpC,UAAMC,IAAI,GAAGvB,mCAAmC,CAAC1B,IAAD,EAAOI,KAAP,CAAhD;AACA,UAAI6C,IAAJ,EAAU5C,KAAK,CAACU,IAAN,CAAWkC,IAAX;AACX;AACF;;AAED,MAAI5C,KAAK,CAACW,MAAV,EAAkB;AAChB,QAAIxB,kBAAkB,CAACa,KAAK,CAAC,CAAD,CAAN,CAAlB,IAAgChB,iBAApC,EAAuD;AACrD,aAAO;AACLa,QAAAA,cAAc,EAAEb,iBAAiB,CAACgB,KAAD,CAD5B;AAELO,QAAAA,WAAW,EAAXA;AAFK,OAAP;AAID;;AAED,QAAIxB,mBAAJ,EAAyB;AACvB,aAAO;AACLc,QAAAA,cAAc,EAAEd,mBAAmB,CAACiB,KAAD,CAD9B;AAELO,QAAAA,WAAW,EAAXA;AAFK,OAAP;AAID;;AAED,WAAO;AACLV,MAAAA,cAAc,EAAEX,yBAAyB,CAACc,KAAD,CADpC;AAELO,MAAAA,WAAW,EAAXA;AAFK,KAAP;AAID;;AAED,SAAOF,wBAAwB,CAACE,WAAD,EAAcZ,IAAd,CAA/B;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createFlowUnionType,\n  createTSUnionType,\n  createTypeAnnotationBasedOnTypeof,\n  createUnionTypeAnnotation,\n  isTSTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n    return createTSUnionType(types);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(types);\n  }\n\n  return createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n      return {\n        typeAnnotation: createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (createFlowUnionType) {\n      return {\n        typeAnnotation: createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}"]},"metadata":{},"sourceType":"script"}