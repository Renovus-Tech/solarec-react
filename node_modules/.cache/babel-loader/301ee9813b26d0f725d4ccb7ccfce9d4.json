{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar isBinding = _t.isBinding,\n    isBlockScoped = _t.isBlockScoped,\n    isExportDeclaration = _t.isExportDeclaration,\n    isExpression = _t.isExpression,\n    isFlow = _t.isFlow,\n    isForStatement = _t.isForStatement,\n    isForXStatement = _t.isForXStatement,\n    isIdentifier = _t.isIdentifier,\n    isImportDeclaration = _t.isImportDeclaration,\n    isImportSpecifier = _t.isImportSpecifier,\n    isJSXIdentifier = _t.isJSXIdentifier,\n    isJSXMemberExpression = _t.isJSXMemberExpression,\n    isMemberExpression = _t.isMemberExpression,\n    isReferenced = _t.isReferenced,\n    isScope = _t.isScope,\n    isStatement = _t.isStatement,\n    isVar = _t.isVar,\n    isVariableDeclaration = _t.isVariableDeclaration,\n    react = _t.react;\nvar isCompatTag = react.isCompatTag;\nvar ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n  checkPath: function checkPath(path, opts) {\n    var node = path.node,\n        parent = path.parent;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nvar ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n  checkPath: function checkPath(_ref) {\n    var node = _ref.node,\n        parent = _ref.parent;\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nvar BindingIdentifier = {\n  types: [\"Identifier\"],\n  checkPath: function checkPath(path) {\n    var node = path.node,\n        parent = path.parent;\n    var grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n};\nexports.BindingIdentifier = BindingIdentifier;\nvar Statement = {\n  types: [\"Statement\"],\n  checkPath: function checkPath(_ref2) {\n    var node = _ref2.node,\n        parent = _ref2.parent;\n\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\nexports.Statement = Statement;\nvar Expression = {\n  types: [\"Expression\"],\n  checkPath: function checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n};\nexports.Expression = Expression;\nvar Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n  checkPath: function checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n};\nexports.Scope = Scope;\nvar Referenced = {\n  checkPath: function checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n};\nexports.Referenced = Referenced;\nvar BlockScoped = {\n  checkPath: function checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n};\nexports.BlockScoped = BlockScoped;\nvar Var = {\n  types: [\"VariableDeclaration\"],\n  checkPath: function checkPath(path) {\n    return isVar(path.node);\n  }\n};\nexports.Var = Var;\nvar User = {\n  checkPath: function checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n};\nexports.User = User;\nvar Generated = {\n  checkPath: function checkPath(path) {\n    return !path.isUser();\n  }\n};\nexports.Generated = Generated;\nvar Pure = {\n  checkPath: function checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n};\nexports.Pure = Pure;\nvar Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n  checkPath: function checkPath(_ref3) {\n    var node = _ref3.node;\n\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n};\nexports.Flow = Flow;\nvar RestProperty = {\n  types: [\"RestElement\"],\n  checkPath: function checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n};\nexports.RestProperty = RestProperty;\nvar SpreadProperty = {\n  types: [\"RestElement\"],\n  checkPath: function checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n};\nexports.SpreadProperty = SpreadProperty;\nvar ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nvar NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nvar ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n  checkPath: function checkPath(_ref4) {\n    var node = _ref4.node;\n    return node.await === true;\n  }\n};\nexports.ForAwaitStatement = ForAwaitStatement;","map":{"version":3,"sources":["C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"],"names":["Object","defineProperty","exports","value","Var","User","Statement","SpreadProperty","Scope","RestProperty","ReferencedMemberExpression","ReferencedIdentifier","Referenced","Pure","NumericLiteralTypeAnnotation","Generated","ForAwaitStatement","Flow","Expression","ExistentialTypeParam","BlockScoped","BindingIdentifier","_t","require","isBinding","isBlockScoped","isExportDeclaration","isExpression","isFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isReferenced","isScope","isStatement","isVar","isVariableDeclaration","react","isCompatTag","types","checkPath","path","opts","node","parent","name","parentPath","grandparent","left","init","isReferencedIdentifier","loc","isUser","scope","isPure","importKind","exportKind","isObjectPattern","isObjectExpression","await"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;"]},"metadata":{},"sourceType":"script"}