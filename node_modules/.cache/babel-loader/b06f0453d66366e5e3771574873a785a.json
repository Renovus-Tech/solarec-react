{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nvar NOT_LOCAL_BINDING = _t.NOT_LOCAL_BINDING,\n    callExpression = _t.callExpression,\n    cloneNode = _t.cloneNode,\n    getBindingIdentifiers = _t.getBindingIdentifiers,\n    identifier = _t.identifier,\n    isArrayExpression = _t.isArrayExpression,\n    isBinary = _t.isBinary,\n    isClass = _t.isClass,\n    isClassBody = _t.isClassBody,\n    isClassDeclaration = _t.isClassDeclaration,\n    isExportAllDeclaration = _t.isExportAllDeclaration,\n    isExportDefaultDeclaration = _t.isExportDefaultDeclaration,\n    isExportNamedDeclaration = _t.isExportNamedDeclaration,\n    isFunctionDeclaration = _t.isFunctionDeclaration,\n    isIdentifier = _t.isIdentifier,\n    isImportDeclaration = _t.isImportDeclaration,\n    isLiteral = _t.isLiteral,\n    isMethod = _t.isMethod,\n    isModuleDeclaration = _t.isModuleDeclaration,\n    isModuleSpecifier = _t.isModuleSpecifier,\n    isObjectExpression = _t.isObjectExpression,\n    isProperty = _t.isProperty,\n    isPureish = _t.isPureish,\n    isSuper = _t.isSuper,\n    isTaggedTemplateExpression = _t.isTaggedTemplateExpression,\n    isTemplateLiteral = _t.isTemplateLiteral,\n    isThisExpression = _t.isThisExpression,\n    isUnaryExpression = _t.isUnaryExpression,\n    isVariableDeclaration = _t.isVariableDeclaration,\n    matchesPattern = _t.matchesPattern,\n    memberExpression = _t.memberExpression,\n    numericLiteral = _t.numericLiteral,\n    toIdentifier = _t.toIdentifier,\n    unaryExpression = _t.unaryExpression,\n    variableDeclaration = _t.variableDeclaration,\n    variableDeclarator = _t.variableDeclarator;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          var _iterator = _createForOfIteratorHelper(node.specifiers),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var e = _step.value;\n              gatherNodeParts(e, parts);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      var _iterator2 = _createForOfIteratorHelper(node.properties),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _e = _step2.value;\n          gatherNodeParts(_e, parts);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nvar collectorVisitor = {\n  ForStatement: function ForStatement(path) {\n    var declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      var scope = path.scope;\n      var parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n  Declaration: function Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n  ImportDeclaration: function ImportDeclaration(path) {\n    var parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n  ForXStatement: function ForXStatement(path, state) {\n    var left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      var scope = path.scope;\n      var parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n  ExportDeclaration: {\n    exit: function exit(path) {\n      var node = path.node,\n          scope = path.scope;\n      if (isExportAllDeclaration(node)) return;\n      var declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        var id = declar.id;\n        if (!id) return;\n        var binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        var _iterator3 = _createForOfIteratorHelper(declar.declarations),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var decl = _step3.value;\n\n            for (var _i = 0, _Object$keys = Object.keys(getBindingIdentifiers(decl)); _i < _Object$keys.length; _i++) {\n              var name = _Object$keys[_i];\n\n              var _binding2 = scope.getBinding(name);\n\n              _binding2 == null ? void 0 : _binding2.reference(path);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  },\n  LabeledStatement: function LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n  AssignmentExpression: function AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n  UpdateExpression: function UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n  UnaryExpression: function UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n  BlockScoped: function BlockScoped(path) {\n    var scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    var parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      var id = path.node.id;\n      var name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n  CatchClause: function CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n  Function: function Function(path) {\n    var params = path.get(\"params\");\n\n    var _iterator4 = _createForOfIteratorHelper(params),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var param = _step4.value;\n        path.scope.registerBinding(\"param\", param);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n  ClassExpression: function ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n};\nvar uid = 0;\n\nvar Scope = /*#__PURE__*/function () {\n  function Scope(path) {\n    _classCallCheck(this, Scope);\n\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    var node = path.node;\n\n    var cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  _createClass(Scope, [{\n    key: \"parent\",\n    get: function get() {\n      var _parent;\n\n      var parent,\n          path = this.path;\n\n      do {\n        var isKey = path.key === \"key\";\n        path = path.parentPath;\n        if (isKey && path.isMethod()) path = path.parentPath;\n        if (path && path.isScope()) parent = path;\n      } while (path && !parent);\n\n      return (_parent = parent) == null ? void 0 : _parent.scope;\n    }\n  }, {\n    key: \"parentBlock\",\n    get: function get() {\n      return this.path.parent;\n    }\n  }, {\n    key: \"hub\",\n    get: function get() {\n      return this.path.hub;\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(node, opts, state) {\n      (0, _index.default)(node, opts, this, state, this.path);\n    }\n  }, {\n    key: \"generateDeclaredUidIdentifier\",\n    value: function generateDeclaredUidIdentifier(name) {\n      var id = this.generateUidIdentifier(name);\n      this.push({\n        id: id\n      });\n      return cloneNode(id);\n    }\n  }, {\n    key: \"generateUidIdentifier\",\n    value: function generateUidIdentifier(name) {\n      return identifier(this.generateUid(name));\n    }\n  }, {\n    key: \"generateUid\",\n    value: function generateUid() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n      name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n      var uid;\n      var i = 1;\n\n      do {\n        uid = this._generateUid(name, i);\n        i++;\n      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n      var program = this.getProgramParent();\n      program.references[uid] = true;\n      program.uids[uid] = true;\n      return uid;\n    }\n  }, {\n    key: \"_generateUid\",\n    value: function _generateUid(name, i) {\n      var id = name;\n      if (i > 1) id += i;\n      return \"_\".concat(id);\n    }\n  }, {\n    key: \"generateUidBasedOnNode\",\n    value: function generateUidBasedOnNode(node, defaultName) {\n      var parts = [];\n      gatherNodeParts(node, parts);\n      var id = parts.join(\"$\");\n      id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n      return this.generateUid(id.slice(0, 20));\n    }\n  }, {\n    key: \"generateUidIdentifierBasedOnNode\",\n    value: function generateUidIdentifierBasedOnNode(node, defaultName) {\n      return identifier(this.generateUidBasedOnNode(node, defaultName));\n    }\n  }, {\n    key: \"isStatic\",\n    value: function isStatic(node) {\n      if (isThisExpression(node) || isSuper(node)) {\n        return true;\n      }\n\n      if (isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n\n        if (binding) {\n          return binding.constant;\n        } else {\n          return this.hasBinding(node.name);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"maybeGenerateMemoised\",\n    value: function maybeGenerateMemoised(node, dontPush) {\n      if (this.isStatic(node)) {\n        return null;\n      } else {\n        var id = this.generateUidIdentifierBasedOnNode(node);\n\n        if (!dontPush) {\n          this.push({\n            id: id\n          });\n          return cloneNode(id);\n        }\n\n        return id;\n      }\n    }\n  }, {\n    key: \"checkBlockScopedCollisions\",\n    value: function checkBlockScopedCollisions(local, kind, name, id) {\n      if (kind === \"param\") return;\n      if (local.kind === \"local\") return;\n      var duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n      if (duplicate) {\n        throw this.hub.buildError(id, \"Duplicate declaration \\\"\".concat(name, \"\\\"\"), TypeError);\n      }\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(oldName, newName, block) {\n      var binding = this.getBinding(oldName);\n\n      if (binding) {\n        newName = newName || this.generateUidIdentifier(oldName).name;\n        return new _renamer.default(binding, oldName, newName).rename(block);\n      }\n    }\n  }, {\n    key: \"_renameFromMap\",\n    value: function _renameFromMap(map, oldName, newName, value) {\n      if (map[oldName]) {\n        map[newName] = value;\n        map[oldName] = null;\n      }\n    }\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      var sep = \"-\".repeat(60);\n      console.log(sep);\n      var scope = this;\n\n      do {\n        console.log(\"#\", scope.block.type);\n\n        for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {\n          var name = _Object$keys2[_i2];\n          var binding = scope.bindings[name];\n          console.log(\" -\", name, {\n            constant: binding.constant,\n            references: binding.references,\n            violations: binding.constantViolations.length,\n            kind: binding.kind\n          });\n        }\n      } while (scope = scope.parent);\n\n      console.log(sep);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(node, i, arrayLikeIsIterable) {\n      if (isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n\n        if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n          return node;\n        }\n      }\n\n      if (isArrayExpression(node)) {\n        return node;\n      }\n\n      if (isIdentifier(node, {\n        name: \"arguments\"\n      })) {\n        return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n      }\n\n      var helperName;\n      var args = [node];\n\n      if (i === true) {\n        helperName = \"toConsumableArray\";\n      } else if (i) {\n        args.push(numericLiteral(i));\n        helperName = \"slicedToArray\";\n      } else {\n        helperName = \"toArray\";\n      }\n\n      if (arrayLikeIsIterable) {\n        args.unshift(this.hub.addHelper(helperName));\n        helperName = \"maybeArrayLike\";\n      }\n\n      return callExpression(this.hub.addHelper(helperName), args);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(name) {\n      return !!this.getLabel(name);\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(name) {\n      return this.labels.get(name);\n    }\n  }, {\n    key: \"registerLabel\",\n    value: function registerLabel(path) {\n      this.labels.set(path.node.label.name, path);\n    }\n  }, {\n    key: \"registerDeclaration\",\n    value: function registerDeclaration(path) {\n      if (path.isLabeledStatement()) {\n        this.registerLabel(path);\n      } else if (path.isFunctionDeclaration()) {\n        this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n      } else if (path.isVariableDeclaration()) {\n        var declarations = path.get(\"declarations\");\n\n        var _iterator5 = _createForOfIteratorHelper(declarations),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var declar = _step5.value;\n            this.registerBinding(path.node.kind, declar);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else if (path.isClassDeclaration()) {\n        this.registerBinding(\"let\", path);\n      } else if (path.isImportDeclaration()) {\n        var specifiers = path.get(\"specifiers\");\n\n        var _iterator6 = _createForOfIteratorHelper(specifiers),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var specifier = _step6.value;\n            this.registerBinding(\"module\", specifier);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } else if (path.isExportDeclaration()) {\n        var _declar = path.get(\"declaration\");\n\n        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {\n          this.registerDeclaration(_declar);\n        }\n      } else {\n        this.registerBinding(\"unknown\", path);\n      }\n    }\n  }, {\n    key: \"buildUndefinedNode\",\n    value: function buildUndefinedNode() {\n      return unaryExpression(\"void\", numericLiteral(0), true);\n    }\n  }, {\n    key: \"registerConstantViolation\",\n    value: function registerConstantViolation(path) {\n      var ids = path.getBindingIdentifiers();\n\n      for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {\n        var name = _Object$keys3[_i3];\n        var binding = this.getBinding(name);\n        if (binding) binding.reassign(path);\n      }\n    }\n  }, {\n    key: \"registerBinding\",\n    value: function registerBinding(kind, path) {\n      var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;\n      if (!kind) throw new ReferenceError(\"no `kind`\");\n\n      if (path.isVariableDeclaration()) {\n        var declarators = path.get(\"declarations\");\n\n        var _iterator7 = _createForOfIteratorHelper(declarators),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var declar = _step7.value;\n            this.registerBinding(kind, declar);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        return;\n      }\n\n      var parent = this.getProgramParent();\n      var ids = path.getOuterBindingIdentifiers(true);\n\n      for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {\n        var name = _Object$keys4[_i4];\n        parent.references[name] = true;\n\n        var _iterator8 = _createForOfIteratorHelper(ids[name]),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var id = _step8.value;\n            var local = this.getOwnBinding(name);\n\n            if (local) {\n              if (local.identifier === id) continue;\n              this.checkBlockScopedCollisions(local, kind, name, id);\n            }\n\n            if (local) {\n              this.registerConstantViolation(bindingPath);\n            } else {\n              this.bindings[name] = new _binding.default({\n                identifier: id,\n                scope: this,\n                path: bindingPath,\n                kind: kind\n              });\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n    }\n  }, {\n    key: \"addGlobal\",\n    value: function addGlobal(node) {\n      this.globals[node.name] = node;\n    }\n  }, {\n    key: \"hasUid\",\n    value: function hasUid(name) {\n      var scope = this;\n\n      do {\n        if (scope.uids[name]) return true;\n      } while (scope = scope.parent);\n\n      return false;\n    }\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(name) {\n      var scope = this;\n\n      do {\n        if (scope.globals[name]) return true;\n      } while (scope = scope.parent);\n\n      return false;\n    }\n  }, {\n    key: \"hasReference\",\n    value: function hasReference(name) {\n      return !!this.getProgramParent().references[name];\n    }\n  }, {\n    key: \"isPure\",\n    value: function isPure(node, constantsOnly) {\n      if (isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n        if (!binding) return false;\n        if (constantsOnly) return binding.constant;\n        return true;\n      } else if (isClass(node)) {\n        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n          return false;\n        }\n\n        return this.isPure(node.body, constantsOnly);\n      } else if (isClassBody(node)) {\n        var _iterator9 = _createForOfIteratorHelper(node.body),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var method = _step9.value;\n            if (!this.isPure(method, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        return true;\n      } else if (isBinary(node)) {\n        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n      } else if (isArrayExpression(node)) {\n        var _iterator10 = _createForOfIteratorHelper(node.elements),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var elem = _step10.value;\n            if (!this.isPure(elem, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        return true;\n      } else if (isObjectExpression(node)) {\n        var _iterator11 = _createForOfIteratorHelper(node.properties),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var prop = _step11.value;\n            if (!this.isPure(prop, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        return true;\n      } else if (isMethod(node)) {\n        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n        if (node.kind === \"get\" || node.kind === \"set\") return false;\n        return true;\n      } else if (isProperty(node)) {\n        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n        return this.isPure(node.value, constantsOnly);\n      } else if (isUnaryExpression(node)) {\n        return this.isPure(node.argument, constantsOnly);\n      } else if (isTaggedTemplateExpression(node)) {\n        return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n      } else if (isTemplateLiteral(node)) {\n        var _iterator12 = _createForOfIteratorHelper(node.expressions),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var expression = _step12.value;\n            if (!this.isPure(expression, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n\n        return true;\n      } else {\n        return isPureish(node);\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(key, val) {\n      return this.data[key] = val;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(key) {\n      var scope = this;\n\n      do {\n        var data = scope.data[key];\n        if (data != null) return data;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"removeData\",\n    value: function removeData(key) {\n      var scope = this;\n\n      do {\n        var data = scope.data[key];\n        if (data != null) scope.data[key] = null;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      if (!this.inited) {\n        this.inited = true;\n        this.crawl();\n      }\n    }\n  }, {\n    key: \"crawl\",\n    value: function crawl() {\n      var path = this.path;\n      this.references = Object.create(null);\n      this.bindings = Object.create(null);\n      this.globals = Object.create(null);\n      this.uids = Object.create(null);\n      this.data = Object.create(null);\n      var programParent = this.getProgramParent();\n      if (programParent.crawling) return;\n      var state = {\n        references: [],\n        constantViolations: [],\n        assignments: []\n      };\n      this.crawling = true;\n\n      if (path.type !== \"Program\" && collectorVisitor._exploded) {\n        var _iterator13 = _createForOfIteratorHelper(collectorVisitor.enter),\n            _step13;\n\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var _visit = _step13.value;\n\n            _visit(path, state);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n\n        var typeVisitors = collectorVisitor[path.type];\n\n        if (typeVisitors) {\n          var _iterator14 = _createForOfIteratorHelper(typeVisitors.enter),\n              _step14;\n\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var visit = _step14.value;\n              visit(path, state);\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        }\n      }\n\n      path.traverse(collectorVisitor, state);\n      this.crawling = false;\n\n      var _iterator15 = _createForOfIteratorHelper(state.assignments),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _path = _step15.value;\n\n          var ids = _path.getBindingIdentifiers();\n\n          for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {\n            var name = _Object$keys5[_i5];\n            if (_path.scope.getBinding(name)) continue;\n            programParent.addGlobal(ids[name]);\n          }\n\n          _path.scope.registerConstantViolation(_path);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      var _iterator16 = _createForOfIteratorHelper(state.references),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var ref = _step16.value;\n          var binding = ref.scope.getBinding(ref.node.name);\n\n          if (binding) {\n            binding.reference(ref);\n          } else {\n            programParent.addGlobal(ref.node);\n          }\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n\n      var _iterator17 = _createForOfIteratorHelper(state.constantViolations),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _path2 = _step17.value;\n\n          _path2.scope.registerConstantViolation(_path2);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(opts) {\n      var path = this.path;\n\n      if (!path.isBlockStatement() && !path.isProgram()) {\n        path = this.getBlockParent().path;\n      }\n\n      if (path.isSwitchStatement()) {\n        path = (this.getFunctionParent() || this.getProgramParent()).path;\n      }\n\n      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n        path.ensureBlock();\n        path = path.get(\"body\");\n      }\n\n      var unique = opts.unique;\n      var kind = opts.kind || \"var\";\n      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n      var dataKey = \"declaration:\".concat(kind, \":\").concat(blockHoist);\n      var declarPath = !unique && path.getData(dataKey);\n\n      if (!declarPath) {\n        var declar = variableDeclaration(kind, []);\n        declar._blockHoist = blockHoist;\n\n        var _path$unshiftContaine = path.unshiftContainer(\"body\", [declar]);\n\n        var _path$unshiftContaine2 = _slicedToArray(_path$unshiftContaine, 1);\n\n        declarPath = _path$unshiftContaine2[0];\n        if (!unique) path.setData(dataKey, declarPath);\n      }\n\n      var declarator = variableDeclarator(opts.id, opts.init);\n      declarPath.node.declarations.push(declarator);\n      this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n    }\n  }, {\n    key: \"getProgramParent\",\n    value: function getProgramParent() {\n      var scope = this;\n\n      do {\n        if (scope.path.isProgram()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n\n      throw new Error(\"Couldn't find a Program\");\n    }\n  }, {\n    key: \"getFunctionParent\",\n    value: function getFunctionParent() {\n      var scope = this;\n\n      do {\n        if (scope.path.isFunctionParent()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n\n      return null;\n    }\n  }, {\n    key: \"getBlockParent\",\n    value: function getBlockParent() {\n      var scope = this;\n\n      do {\n        if (scope.path.isBlockParent()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n\n      throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n    }\n  }, {\n    key: \"getAllBindings\",\n    value: function getAllBindings() {\n      var ids = Object.create(null);\n      var scope = this;\n\n      do {\n        for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {\n          var key = _Object$keys6[_i6];\n\n          if (key in ids === false) {\n            ids[key] = scope.bindings[key];\n          }\n        }\n\n        scope = scope.parent;\n      } while (scope);\n\n      return ids;\n    }\n  }, {\n    key: \"getAllBindingsOfKind\",\n    value: function getAllBindingsOfKind() {\n      var ids = Object.create(null);\n\n      for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {\n        kinds[_key] = arguments[_key];\n      }\n\n      for (var _i7 = 0, _kinds = kinds; _i7 < _kinds.length; _i7++) {\n        var kind = _kinds[_i7];\n        var scope = this;\n\n        do {\n          for (var _i8 = 0, _Object$keys7 = Object.keys(scope.bindings); _i8 < _Object$keys7.length; _i8++) {\n            var name = _Object$keys7[_i8];\n            var binding = scope.bindings[name];\n            if (binding.kind === kind) ids[name] = binding;\n          }\n\n          scope = scope.parent;\n        } while (scope);\n      }\n\n      return ids;\n    }\n  }, {\n    key: \"bindingIdentifierEquals\",\n    value: function bindingIdentifierEquals(name, node) {\n      return this.getBindingIdentifier(name) === node;\n    }\n  }, {\n    key: \"getBinding\",\n    value: function getBinding(name) {\n      var scope = this;\n      var previousPath;\n\n      do {\n        var binding = scope.getOwnBinding(name);\n\n        if (binding) {\n          var _previousPath;\n\n          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n            return binding;\n          }\n        }\n\n        previousPath = scope.path;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"getOwnBinding\",\n    value: function getOwnBinding(name) {\n      return this.bindings[name];\n    }\n  }, {\n    key: \"getBindingIdentifier\",\n    value: function getBindingIdentifier(name) {\n      var _this$getBinding;\n\n      return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n    }\n  }, {\n    key: \"getOwnBindingIdentifier\",\n    value: function getOwnBindingIdentifier(name) {\n      var binding = this.bindings[name];\n      return binding == null ? void 0 : binding.identifier;\n    }\n  }, {\n    key: \"hasOwnBinding\",\n    value: function hasOwnBinding(name) {\n      return !!this.getOwnBinding(name);\n    }\n  }, {\n    key: \"hasBinding\",\n    value: function hasBinding(name, noGlobals) {\n      if (!name) return false;\n      if (this.hasOwnBinding(name)) return true;\n      if (this.parentHasBinding(name, noGlobals)) return true;\n      if (this.hasUid(name)) return true;\n      if (!noGlobals && Scope.globals.includes(name)) return true;\n      if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n      return false;\n    }\n  }, {\n    key: \"parentHasBinding\",\n    value: function parentHasBinding(name, noGlobals) {\n      var _this$parent;\n\n      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n    }\n  }, {\n    key: \"moveBindingTo\",\n    value: function moveBindingTo(name, scope) {\n      var info = this.getBinding(name);\n\n      if (info) {\n        info.scope.removeOwnBinding(name);\n        info.scope = scope;\n        scope.bindings[name] = info;\n      }\n    }\n  }, {\n    key: \"removeOwnBinding\",\n    value: function removeOwnBinding(name) {\n      delete this.bindings[name];\n    }\n  }, {\n    key: \"removeBinding\",\n    value: function removeBinding(name) {\n      var _this$getBinding2;\n\n      (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n      var scope = this;\n\n      do {\n        if (scope.uids[name]) {\n          scope.uids[name] = false;\n        }\n      } while (scope = scope.parent);\n    }\n  }]);\n\n  return Scope;\n}();\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"sources":["C:/Users/nicob/Desktop/Renovus/renovus/falconer_ui_web/node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/index.js"],"names":["Object","defineProperty","exports","value","default","_renamer","require","_index","_binding","_globals","_t","_cache","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isObjectExpression","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","gatherNodeParts","node","parts","type","source","specifiers","length","e","declaration","local","push","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","declarations","decl","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","Scope","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","isKey","parentPath","isScope","hub","opts","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","join","slice","generateUidBasedOnNode","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","duplicate","buildError","TypeError","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","superClass","isPure","body","method","right","elements","elem","prop","computed","tag","quasi","expressions","val","crawl","create","programParent","_exploded","enter","visit","typeVisitors","traverse","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","unshiftContainer","setData","declarator","init","pop","Error","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];"]},"metadata":{},"sourceType":"script"}